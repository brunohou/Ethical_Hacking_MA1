# Frequency generator

This project takes place in the course of Hardware & Software Platforms given by Pr. Valderrama.

Made by Louis Aromatario & Alberto Badilini
2021-2022, FPMS (UMons)

## Reading before realisation

The objective of the project is to create an hardware driver on a FPGA and a application program for a frequency generator. It was developed on the DE0-Nano-SoC kit (SoC FPGA + ARM Hard Processor System + USB and alimentation cables) with the Intel Altera SoC Qsys (synthesis & simulation of FPGA and platform designer). You'll also need to install the Putty programm on your PC.

The goal is to be able to output a wanted frequency on one of the I/O port of the FPGA. The user will enter a 8-bit value (in decimal) thanks to the user interface (application program)

The FPGA will thus receive as an input a value from 0 to 255 as a std_logic_vector. It will generate a frequency between 50Hz and 50kHz; the value 0 corresponds to the minimum period of 20µs (f=50kHz) and 255 corresponds to the maximum period of 20 ms (f=50Hz). Every value n corresponds to a period of 20µs + n*TIMESTEP where the TIMESTEP is equal to (20ms-20µs)/255=78µs.

Seeing that we have an internal clock of 50Mhz (period=20ns) we can convert all the time values in pure clock counts so they become:
STEP= 78µs/20ns=3900 ;
MINCOUNT=20µs/20ns=1000 ;
MAXCOUNT= 20ms/20ns=1000000

The output pin will only stay high for one cycle of the 50MHz clock every period. This function is managed by the FreqOut.VHDL file, while the FreqOut_TB.VHDL is used as a testbench.

The input registers (the one for the input value and the one for the enable pin that must be set to generate the frequency) are controlled by the software driver in the processor that, after taking the address of the registers, writes the desired value for the period (still using a number from 0 to 255 as explained before) in the correct place. Those functions are managed by the main.c file.

## Step-by-step tutorial

### 1) Platform Designer 

After opening the project archive in Quartus, go in the "tools" tab and click on "platform designer". This tool shows the main components of the board and their connections (HPS processor, Jtag/Uart, buttons, led and switches). Our process will need 2 registers, for the enable and input value. To create these 2 registers, we first need to add external connections to the processor that will connect it to the Avalon bus. 

Click on the "add" button and create 2 external connections, "pio_reg1" and "pio_reg2" both being a 8-bit vector.

You can now click on "generate"

### 2) The top-level file : ghrd.v

We end up with this file, generated by the platform designer. We can see all the board pins that can be used, the clock signals, the GPIO pins and the 2 external connections we created (line 160 and 161). The file is also meant to declare all the internal wires and registers. Indeed, we still need to create the 2 registers. Their declaration can be found at the line 142 and 143 and their connection to their respective external connection leading to the processor is done at lines 160 and 161.

### 3) Hardware driver : FreqOUT.vhd

This file describe the logical circuit that will perform our function (generating a frequency from the 50MHz clock) and that will be implemented in the FPGA. It has 4 inputs and 1 output. Additional comments can be found in the file.

Before going further, we need to describe the connection between the FPGA logic circuit and the registers/I-O pins in the top level file. You'll find at the end of ghrd.v a FreqOut instance (same name as in the VHDL file) that connects the inputs/outputs of the logic to the 2 registers, the already declared reset wire and the first element of the GPIO[] vector (first pin).

### 4) Testbench of the driver: FreqOUT_TB.vhd

The test bench will allow us to check if the logic part is doing what we're expecting. it's the file that will dictate the simulation done by ModelSim. To achieve this we call an instance of the predefined FreqOut component and assign signals to its ports. By controlling ourself the signals, we can test if it behaves correctly. Additional comments can be found in the file.

### 5) Software development: main.c

This file will manage the value put in the registers that the FPGA sees as input. The values stored in the 2 registers reg1_to_add and reg2_to_add are manipulated with pointers named "uint8_t *h2p_lw_reg1_addr"* and "uint8_t *h2p_lw_reg2_addr"*. The exact adress of the registers is assigned to the pointers at lines 77 and 78 with the help of headers. When calling the functions, the user must enter the different 8-bit values (in decimal) that he wants to see translated in frequency. The number of values will be automatically stored as a chain of characters in the vector argv, and argc will contain the length of argv. Note that argv[0] is always the address of the variable and argv[arc-1] is always NULL, the iterator is therefore stating at 1 and ending at argc-2.

We can therefore make a loop that will store in the reg1_to_add register one of the value of argv, waiting 2 seconds before going to the next one.

### 6) Programming the processor and the FPGA

To program the FPGA, connect the board to the PC using the USB blaster (connected on the same side as the power). Go in tools>programmer and click on "harware setup", you'll find the DE-SOC [USB-1], select it and close. Click on "add file" and find the "HPS_CONTROL_FPGA_LED.sof" in the directory of the project. Add it and click on "Start". Your FPGA is now programmed.

Connect now the USB blaster to the other side and connect the board to the ethernet. Open your peripherals manager to find the number of the port the board is connected to. Open Putty, select "serial" mode, enter the serial line that you found, put 115200 as baudrate and click open. The linux terminal opens and you can enter "root" as login and type ifcongig to see the IP address of the board.

Start the SoC EDS Shell and access the directory of your project. You'll find the HPS-FREQOUT file that was generated from the main.c and converted into a file that can be executed in the linux OS of the processor. If you modified the main.c, juste type "makefile" to call the file that will do the conversion.

Finally, to run the generated file, type "scp HPS_FREQOUTroot@255.255.255.255:/home/root" and replace the IP address with the retrieved one.

All that's left to do is type "./HPS_FREQ" in the putty terminal, followed by the input values (in decimal) that you want to see in frequency on the GPIO_0[0].




